<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Play Cat</title>

    <link rel="stylesheet" href="/stylesheets/styles.css">
    <link rel="stylesheet" href="/stylesheets/pygment_trac.css">
    <script src="/javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>
<body>
<div class="wrapper">
    <header>
        <h1 class="header">喵呜呜</h1>
        <p class="header">I like green</p>

        <ul>
            <li class="download"><a class="buttons" href="https://github.com/reelin/blog/zipball/master">Download ZIP</a></li>
            <li class="download"><a class="buttons" href="https://github.com/reelin/blog/tarball/master">Download TAR</a></li>
            <li><a class="buttons github" href="https://github.com/reelin/blog">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/reelin">reelin</a></p>


    </header>
    <section>
        <div class="post">
    <h2>三道搜狐面试题（答案）</h2>
    <div><ul>
<li><p>题目一：实现一个遍历数组或对象里所有成员的迭代器</p>

<ol>
<li><p>调用each函数的参数内部使用了<code>this</code>，将obj的属性值当做了此时的<code>this</code>.<code>Function.call()</code> 可以将函数作为对象的方法调用，可单独指定传递的参数；<code>Function.apply()</code> 的参数要传入数组元素。在此更适合使用call()将<code>value</code>当做此时的<code>this</code>，并且调用<code>fn</code>函数。</p></li>
<li><p>由于数组和对象传递的参数不同，要判断数组和对象，使用typeof得到的返回值都是object。ECMAscript 5中可以使用Array.isArray()函数来判断。ECMAscript 3中可以这样判断：对象的类属性是一个字符串，表示对象的类型信息。可以用默认的toString()方法 (继承自Object.prototype) 返回<code>[object class]</code>。但很多对象继承的toString方法可能被重写过，为了能够调用到正确的toString()版本，必须间接的调用Function.call()。</p>

<pre><code>var isAarry = (Array.isArray) ? Array.isArray(obj) : 
          typeof obj === "object" &amp;&amp; 
          Object.prototype.toString.call(obj) === "[object Array]";
</code></pre></li>
</ol>


<p><a herf="/code/exam/Man.html">查看第一题答案</a></p></li>
<li><p>题目二，实现一个叫Man的类，包含attr, words, say三个方法</p>

<ol>
<li><p>Me的创建，有两种方法，用new来创建的时候会调用构造函数。调用构造函数的一个重要特征是，构造函数的prototype属性被用作新对象的原型。而该属性包含constructor属性。因此，<code>me.constructor === Man</code>。根据，这个不同，在Man中判断对象me是否属于Man这个类</p>

<pre><code>if (this.constructor !== Man) {
    return new Man(obj);
}
</code></pre></li>
<li><p>fullName和gender私有化，这样在外部赋值就不会影响到值的改变，用setter和getter来取值和赋值</p>

<pre><code>var fullname = obj.fullname || "&lt;用户未输入&gt;",
    gender = obj.gender || "&lt;用户未输入&gt;";

// setter赋值
this.set_fullname = function(value) {
    fullname = value;
}

this.set_gender = function(value) {
    gender = value;
}

// getter取值
this.get_fullname = function() {
    return fullname;
}

this.get_gender = function() {
    return gender;
}
</code></pre></li>
<li><p>attr方法。用可变的参数数组argument的长度的不同，进行不同的操作。在长度为一的时候判断类型，是对象的话就批量setter。</p></li>
<li><p>words方法。我设了一个属性sayWords来存放words。</p></li>
<li><p>says方法。根据word-limit的长度来决定输出的sayWords的长度。</p></li>
</ol>


<p><a herf="/code/exam/Man.html">查看第二题答案</a></p></li>
<li><p>题目三，实现一个URI解析方法，把url里#之后的参数解析成指定的数据结构</p>

<ol>
<li><p>match()返回一个数组a，a[0]存放的是完整匹配，之后的依次是圆括号中匹配的子串。根据子串的位子将得到的子串存放到result数组中。</p></li>
<li><p>题目的要求只要#号之后的解析就可，每个部分分解成子串分别调用。</p>

<pre><code>parseUrl = /#((\S+)\?)*(\w+=\S+&amp;*)*/
</code></pre>

<p><a href="/code/exam/urlParse.html">查看第三题答案</a></p></li>
</ol>
</li>
</ul>


<hr />

<p>尊重原创，引用请标注出处，谢谢！</p>
</div>
    <div>Posted on 10 October 2012</div>
</div>

    </section>
    <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
    </footer>
</div>
<!--[if !IE]><script>fixScale(document);</script><![endif]-->
	
</body>
</html>