<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>MiaoWuwu | I Like Green</title>

    <link rel="stylesheet" type="text/less" href="/stylesheets/styles.less">
    
    <meta name="viewport" post="width=device-width, initial-scale=1, user-scalable=no">
    
    <script src="/javascripts/scale.fix.js"></script>
    <script type="text/javascript" src="/javascripts/jquery-1.7.2.min.js"></script>
    <script src="/javascripts/less-1.3.0.min.js" type="text/javascript"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>

<body>
    <header>
        <ul>
            <li><a id="logo" href="/">喵呜呜</a></li>
            <li>
                <a href="/index.html">Blog</a>
            </li>
            <li>
                <a href="/demo.html">Demos</a>
            </li>
            <li>
                <a href="#">About</a>
            </li>
        </ul>

    </header>
    <div class="wrapper">        

        <div id="github">
    <h1>三道搜狐面试题（答案）</h1>
    <div class="content">
    	<div><ul>
<li><p>题目一：实现一个遍历数组或对象里所有成员的迭代器</p>

<ol>
<li><p>调用each函数的参数内部使用了this，将obj的属性值当做了此时的this.Function.call() 可以将函数作为对象的方法调用，可单独指定传递的参数；Function.apply() 的参数要传入数组元素。在此更适合使用call()将value当做此时的this，并且调用fn函数。</p></li>
<li><p>由于数组和对象传递的参数不同，要判断数组和对象，使用typeof得到的返回值都是object。ECMAscript 5中可以使用Array.isArray()函数来判断。ECMAscript 3中可以这样判断：对象的类属性是一个字符串，表示对象的类型信息。可以用默认的toString()方法 (继承自Object.prototype) 返回[object class]。但很多对象继承的toString方法可能被重写过，为了能够调用到正确的toString()版本，必须间接的调用Function.call()。</p>

<pre><code>var isAarry = (Array.isArray) ?
                 Array.isArray(obj) : typeof obj === "object"
                 &amp;&amp; Object.prototype.toString.call(obj) === "[object Array]";
</code></pre></li>
</ol>


<p><a href="/code/exam/">查看第一题答案</a></p></li>
<li><p>题目二，实现一个叫Man的类，包含attr, words, say三个方法</p>

<ol>
<li><p>Me的创建，有两种方法，用new来创建的时候会调用构造函数。调用构造函数的一个重要特征是，构造函数的prototype属性被用作新对象的原型。而该属性包含constructor属性。因此，me.constructor === Man。根据，这个不同，在Man中判断对象me是否属于Man这个类</p>

<pre><code>if (this.constructor !== Man) {
    return new Man(obj);
}
</code></pre>

<p><code>fullName</code>和<code>gender</code>私有化，这样在外部赋值就不会影响到值的改变，用<code>setter</code>和<code>getter</code>来取值和赋值</p>

<pre><code>var fullname = obj.fullname || "&lt;用户未输入&gt;",
    gender = obj.gender || "&lt;用户未输入&gt;";

// setter赋值
this.set_fullname = function(value) {
    fullname = value;
}

this.set_gender = function(value) {
    gender = value;
}

// getter取值
this.get_fullname = function() {
    return fullname;
}

this.get_gender = function() {
    return gender;
}
</code></pre></li>
<li><p>attr方法。用可变的参数数组argument的长度的不同，进行不同的操作。在长度为一的时候判断类型，是对象的话就批量setter。</p></li>
<li><p>words方法。我设了一个属性sayWords来存放words。</p></li>
<li><p>says方法。根据word-limit的长度来决定输出的sayWords的长度。</p></li>
</ol>


<p><a href="/code/exam/Man.html">查看第二题答案</a></p></li>
<li><p>题目三，实现一个URI解析方法，把url里#之后的参数解析成指定的数据结构</p>

<p>match()返回一个数组a，a[0]存放的是完整匹配，之后的依次是圆括号中匹配的子串。根据子串的位子将得到的子串存放到result数组中。</p>

<p>题目的要求只要#号之后的解析就可，每个部分分解成子串分别调用。</p>

<pre><code>parseUrl = /#((\S+)\?)*(\w+=\S+&amp;*)*/
</code></pre>

<p><a href="/code/exam/urlParse.html">查看第三题答案</A></p></li>
</ul>


<hr />

<p>尊重原创，引用请标注出处，谢谢！</p>
</div>
    	<p class="data">Posted on 10 October 2012</p>
    </div>
</div>


        
        <footer>
            <p>Hosted on GitHub Pages — Theme by <a class="header name" href="https://github.com/reelin">reelin</a></p>
        </footer>
    </div>

<script type="text/javascript" src="/javascripts/base.js"></script>

<!--[if !IE]><script>fixScale(document);</script><![endif]-->
</body>
</html>